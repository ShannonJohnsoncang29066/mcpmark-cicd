name: Issue Management Automation

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write
  contents: read

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    steps:
      - name: Auto-label issue based on title and content
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title.toLowerCase();
            const issueBody = issue.body ? issue.body.toLowerCase() : '';
            
            const labelsToAdd = [];
            
            // Add needs-triage label to all new issues
            labelsToAdd.push('needs-triage');
            
            // Category labeling based on title keywords
            if (issueTitle.includes('bug')) {
              labelsToAdd.push('bug');
            } else if (issueTitle.includes('epic')) {
              labelsToAdd.push('epic');
            } else if (issueTitle.includes('maintenance')) {
              labelsToAdd.push('maintenance');
            }
            
            // Priority labeling based on title or body keywords (highest priority wins)
            const priorityKeywords = {
              'priority-critical': ['critical', 'urgent', 'production', 'outage'],
              'priority-high': ['important', 'high', 'blocking'],
              'priority-low': ['low', 'nice-to-have', 'minor'],
              'priority-medium': ['medium', 'normal']
            };
            
            let priorityLabel = 'priority-medium'; // default
            
            for (const [label, keywords] of Object.entries(priorityKeywords)) {
              const hasKeyword = keywords.some(keyword => 
                issueTitle.includes(keyword) || issueBody.includes(keyword)
              );
              
              if (hasKeyword) {
                // Assign highest priority found (critical > high > medium > low)
                if (label === 'priority-critical') {
                  priorityLabel = label;
                  break;
                } else if (label === 'priority-high' && priorityLabel !== 'priority-critical') {
                  priorityLabel = label;
                } else if (label === 'priority-low' && priorityLabel === 'priority-medium') {
                  priorityLabel = label;
                }
              }
            }
            
            labelsToAdd.push(priorityLabel);
            
            // Add labels to issue
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: labelsToAdd
              });
              console.log(`Added labels: ${labelsToAdd.join(', ')}`);
            }

  task-breakdown:
    runs-on: ubuntu-latest
    if: |
      github.event.action == 'opened' && 
      contains(github.event.issue.title, 'epic') || 
      contains(github.event.issue.title, 'Epic')
    needs: issue-triage
    steps:
      - name: Create sub-issues for epic
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const parentNumber = issue.number;
            const parentTitle = issue.title;
            
            // Define the 4 sub-tasks
            const subTasks = [
              { name: 'Requirements Analysis', number: 1 },
              { name: 'Design and Architecture', number: 2 },
              { name: 'Implementation', number: 3 },
              { name: 'Testing and Documentation', number: 4 }
            ];
            
            const createdIssues = [];
            
            // Create each sub-issue
            for (const task of subTasks) {
              const subIssueTitle = `[SUBTASK] ${parentTitle} - Task ${task.number}: ${task.name}`;
              const subIssueBody = `## Related to #${parentNumber}\n\nThis is a sub-task of the epic "${parentTitle}".\n\n### Task: ${task.name}\n\nPlease complete this sub-task as part of the epic implementation.`;
              
              try {
                const subIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: subIssueTitle,
                  body: subIssueBody,
                  labels: ['enhancement', 'needs-review']
                });
                
                createdIssues.push({
                  number: subIssue.data.number,
                  title: subIssueTitle,
                  taskName: task.name
                });
                
                console.log(`Created sub-issue #${subIssue.data.number}: ${subIssueTitle}`);
              } catch (error) {
                console.error(`Failed to create sub-issue for task ${task.number}:`, error);
              }
            }
            
            // Update parent issue with epic tasks checklist
            if (createdIssues.length > 0) {
              const checklist = createdIssues.map(issue => 
                `- [ ] #${issue.number} - ${issue.taskName}`
              ).join('\n');
              
              const epicTasksSection = `\n\n## Epic Tasks\n${checklist}\n\n> This checklist was automatically generated by the issue management workflow.`;
              
              // Get current issue body
              const currentBody = issue.body || '';
              const updatedBody = currentBody + epicTasksSection;
              
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNumber,
                  body: updatedBody
                });
                console.log('Updated parent issue with epic tasks checklist');
              } catch (error) {
                console.error('Failed to update parent issue:', error);
              }
            }

  auto-response:
    runs-on: ubuntu-latest
    needs: issue-triage
    steps:
      - name: Check if first-time contributor and post response
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueAuthor = issue.user.login;
            const issueTitle = issue.title.toLowerCase();
            
            // Check if this is the user's first issue in this repository
            let isFirstIssue = false;
            try {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                creator: issueAuthor,
                state: 'all',
                per_page: 100
              });
              
              // Count issues created by this user (excluding the current one)
              const userIssues = issues.data.filter(i => i.number !== issueNumber);
              isFirstIssue = userIssues.length === 0;
            } catch (error) {
              console.error('Failed to check user issues:', error);
              // Continue even if this check fails
            }
            
            // Add first-time contributor label if applicable
            if (isFirstIssue) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['first-time-contributor']
                });
                console.log('Added first-time-contributor label');
              } catch (error) {
                console.error('Failed to add first-time-contributor label:', error);
              }
            }
            
            // Get issue labels to determine type
            const labels = issue.labels.map(l => l.name);
            const isBug = labels.includes('bug') || issueTitle.includes('bug');
            const isEpic = labels.includes('epic') || issueTitle.includes('epic');
            const isMaintenance = labels.includes('maintenance') || issueTitle.includes('maintenance');
            
            // Prepare response based on issue type
            let responseBody = '';
            
            if (isFirstIssue) {
              responseBody += `## ðŸŽ‰ Welcome @${issueAuthor}!\n\nThank you for opening your first issue in this repository. We appreciate your contribution!\n\n`;
            }
            
            if (isBug) {
              responseBody += `## ðŸ› Bug Report Received\n\nThank you for reporting this bug. Our team will review it shortly.\n\n### Bug Report Guidelines\n- Please ensure you've provided steps to reproduce the issue\n- Include environment details (OS, browser, version)\n- Add any error messages or screenshots\n- Our team will prioritize based on severity and impact\n\nWe'll update you on the progress soon.`;
            } else if (isEpic) {
              responseBody += `## ðŸš€ Epic Feature Request Received\n\nThank you for this comprehensive feature request! This has been identified as an epic and will be broken down into manageable sub-tasks.\n\n### Feature Request Process\n1. The epic has been analyzed and sub-tasks have been created\n2. Each sub-task will be tracked separately\n3. The parent issue will be updated with a checklist of all sub-tasks\n4. Our team will review and prioritize the implementation\n\nPlease review the sub-issues created for this epic.`;
            } else if (isMaintenance) {
              responseBody += `## ðŸ”§ Maintenance Task Received\n\nThank you for identifying this maintenance need.\n\n### Maintenance Guidelines\n- Maintenance tasks help keep the codebase healthy\n- These are typically scheduled based on priority and resource availability\n- We'll review the impact and schedule accordingly\n- Thank you for helping improve the project maintainability!`;
            } else {
              responseBody += `## ðŸ“‹ Issue Received\n\nThank you for submitting this issue. Our team will review it and provide feedback shortly.`;
            }
            
            responseBody += `\n\n---\n*This is an automated response. A maintainer will review your issue soon.*`;
            
            // Post the response comment
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: responseBody
              });
              console.log('Posted auto-response comment');
            } catch (error) {
              console.error('Failed to post comment:', error);
            }
            
            // Set milestone for high and critical priority issues
            const hasHighPriority = labels.includes('priority-high') || labels.includes('priority-critical');
            
            if (hasHighPriority) {
              try {
                // Try to set milestone v1.0.0 (create if it doesn't exist)
                let milestoneNumber = null;
                
                // Check if milestone exists
                const milestones = await github.rest.issues.listMilestones({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open'
                });
                
                const existingMilestone = milestones.data.find(m => m.title === 'v1.0.0');
                
                if (existingMilestone) {
                  milestoneNumber = existingMilestone.number;
                } else {
                  // Create milestone if it doesn't exist
                  const newMilestone = await github.rest.issues.createMilestone({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: 'v1.0.0',
                    state: 'open'
                  });
                  milestoneNumber = newMilestone.data.number;
                  console.log('Created milestone v1.0.0');
                }
                
                // Assign milestone to issue
                if (milestoneNumber) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    milestone: milestoneNumber
                  });
                  console.log(`Assigned milestone v1.0.0 to issue #${issueNumber}`);
                }
              } catch (error) {
                console.error('Failed to assign milestone:', error);
              }
            }
            
            // Change status from needs-triage to needs-review
            try {
              // Remove needs-triage label
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                name: 'needs-triage'
              });
              
              // Add needs-review label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['needs-review']
              });
              
              console.log('Updated status: needs-triage â†’ needs-review');
            } catch (error) {
              console.error('Failed to update status labels:', error);
            }